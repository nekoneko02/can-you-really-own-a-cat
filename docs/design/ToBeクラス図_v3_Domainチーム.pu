@startuml ToBeクラス図_v3_Domainチーム

title Application/Domain層クラス図（MVP）- Domainチーム担当

' ===========================
' Domainチームの担当範囲
' ===========================
' - Application Layer（GameController）
' - Domain Layer（Game, Player, Cat, GameEvent等）
' - 依存方向: Phaser → Application → Domain
' ===========================

' ===========================
' Application Layer
' ===========================

package "Application Layer" <<Database>> as PkgApplication {
  class GameController {
    - game: Game
    + constructor(scenarioId: string)
    + tick(input: PlayerInput): void
    + view(): GameView
  }

  interface PlayerInput {
    direction?: Direction
    interact?: boolean
    choice?: string
    emotion?: EmotionData
  }

  interface GameView {
    phase: GamePhase
    time: number
    day: number
    player: PlayerViewModel
    cat: CatViewModel
    currentEvent: GameEvent | null
    catStatus: CatStatus
    playerStats: PlayerStats
  }

  interface PlayerViewModel {
    x: number
    y: number
    animation: string
    hasToy: boolean
  }

  interface CatViewModel {
    x: number
    y: number
    state: CatState
    mood: CatMood
  }

  enum Direction {
    UP
    DOWN
    LEFT
    RIGHT
    NONE
  }

  GameController --> Game
  GameController --> PlayerInput
  GameController --> GameView
  GameView --> PlayerViewModel
  GameView --> CatViewModel
  GameView --> GameEvent
  GameView --> CatStatus
  GameView --> PlayerStats
  GameView --> GamePhase
  PlayerInput --> Direction
  PlayerInput --> EmotionData
  CatViewModel --> CatState
  CatViewModel --> CatMood
}

note top of PkgApplication
  【Application層の役割】
  PhaserとDomainを仲介する。
  - Phaserから入力を受け取る（tick）
  - Domainを更新する
  - Phaserに描画用データを返す（view）

  【重要】
  - PlayerInput: Phaserからの入力データ
  - GameView: Phaserへの描画データ
  - Direction: Phaser/Domain両方で使用
end note

' ===========================
' Domain Layer
' ===========================

package "Domain Layer" <<Database>> as PkgDomain {
  class Game {
    - scenarioId: string
    - currentPhase: GamePhase
    - currentDay: number
    - currentTime: number
    - player: Player
    - cat: Cat
    - currentEvent: GameEvent | null
    - eventHistory: EventRecord[]
    - catStatusManager: CatStatusManager
    - playerStats: PlayerStats
    + constructor(scenarioId: string)
    + processInput(input: PlayerInput): void
    + update(): void
    + transitionToMidnight(): void
    + checkEventTrigger(): void
    + recordEmotion(emotion: EmotionData): void
    + transitionToMorning(): void
    + advanceToNextDay(): void
    + analyzePlayerBehavior(): string
    + generateReport(): GameResult
    + getPhase(): GamePhase
  }

  class Player {
    - x: number
    - y: number
    - currentAnimation: string
    - hasToy: boolean
    + move(direction: Direction): void
    + interact(targetId: string): void
    + pickUpToy(): void
  }

  class Cat {
    - x: number
    - y: number
    - state: CatState
    - mood: CatMood
    + setState(state: CatState): void
    + setMood(mood: CatMood): void
    + moveTo(x: number, y: number): void
    + catch(): void
    + playWith(toyType: ToyType): void
  }

  class GameEvent {
    + id: string
    + day: number
    + timeOfDay: TimeOfDay
    + title: string
    + description: string
    + catStateDescription: string[]
    + choices: Choice[]
    + trigger(): void
    + executeChoice(choiceId: string): Consequence
    + checkTimeLimit(): boolean
    + completeAction(actionId: string): void
    + getPhaserAction(): PhaserAction | null
  }

  class Choice {
    + id: string
    + text: string
    + phaserAction: PhaserAction | null
    + consequenceText: string
    + execute(): Consequence
  }

  class PhaserAction {
    + type: ActionType
    + targetObject: string
    + requiredAction: InteractionAction
  }

  class Consequence {
    + text: string
    + catStateChanges: Partial<CatStatus>
    + playerStatsChanges: Partial<PlayerStats>
    + eventCompleted: boolean
  }

  enum ActionType {
    MOVE_TO
    INTERACT_WITH
    WAIT
  }

  enum InteractionAction {
    CATCH
    PET
    PICK_UP
    PLAY
  }

  class CatStatus {
    + affection: number
    + stress: number
    + health: number
    + hunger: number
  }

  class CatStatusManager {
    - status: CatStatus
    + updateStatus(changes: Partial<CatStatus>): void
    + getStatus(): CatStatus
  }

  class PlayerStats {
    + totalSleepHours: number
    + interruptionCount: number
    + playCount: number
  }

  enum GamePhase {
    NIGHT_PREP
    MIDNIGHT_EVENT
    MORNING_OUTRO
    GAME_END
  }

  enum TimeOfDay {
    NIGHT
    MIDNIGHT
    MORNING
  }

  enum CatState {
    SLEEPING
    SITTING
    STANDING
    WALKING
    RUNNING
    MEOWING
    PLAYING
  }

  enum CatMood {
    NEUTRAL
    HAPPY
    ANGRY
    SCARED
    SLEEPY
  }

  enum ToyType {
    BALL
    MOUSE
    FEATHER
  }

  Game --> Player
  Game --> Cat
  Game --> GameEvent
  Game --> CatStatusManager
  Game --> PlayerStats
  Game --> GamePhase
  Game --> EventRecord
  GameEvent --> Choice
  GameEvent --> TimeOfDay
  Choice --> PhaserAction
  Choice --> Consequence
  PhaserAction --> ActionType
  PhaserAction --> InteractionAction
  CatStatusManager --> CatStatus
  Consequence --> CatStatus
  Consequence --> PlayerStats
  Cat --> CatState
  Cat --> CatMood
  Cat --> ToyType
  Player --> Direction
}

note top of PkgDomain
  【Domain層の役割】
  ビジネスロジックの中核。

  【重要な設計原則】
  - DomainはPhaserを知らない、Reactを知らない
  - Player.interact(targetId: string)
    → 具体的なオブジェクトではなく、IDで参照
    → 疎結合を維持
  - Cat.playWith(toyType: ToyType)
    → Toyオブジェクトではなく、型のみ
  - Direction, CatState, CatMood, ToyTypeなどのenumはDomain層で定義
    → Phaser層から参照される（依存方向：Phaser→Domain）
end note

' ===========================
' Reactチームとの境界（インターフェース）
' ===========================

package "React Layer (Interface)" as PkgReactInterface {
  interface GameResult {
    scenarioId: string
    completed: boolean
    playerStats: PlayerStats
    finalCatStatus: CatStatus
    eventHistory: EventRecord[]
    report: Report
  }

  interface Report {
    playerBehaviorPattern: string
    feedbackText: string
    emotionLog: EmotionData[]
  }

  interface EventRecord {
    eventId: string
    day: number
    choiceId: string
    emotion: EmotionData
    timestamp: number
  }

  interface EmotionData {
    satisfaction: number
    burden: number
    comment?: string
  }

  GameResult --> PlayerStats
  GameResult --> CatStatus
  GameResult --> EventRecord
  GameResult --> Report
  Report --> EmotionData
  EventRecord --> EmotionData
}

note top of PkgReactInterface
  【Reactチームとの境界】
  - GameResult: Game.generateReport()が生成
  - Reactチームはこのインターフェースを参照
  - 実装はDomainチームが担当
end note

' ===========================
' パッケージ間の関係性
' ===========================

' Application → Domain
PkgApplication.GameController --> PkgDomain.Game : uses

' Domain → React Interface (生成)
PkgDomain.Game ..> PkgReactInterface.GameResult : generateReport()

' ===========================
' 凡例
' ===========================

legend right
  **凡例**
  - <<Database>>: レイヤーパッケージ
  - <<Interface>>: 抽象インターフェース

  **Domainチームの担当範囲**
  ✅ Application Layer（GameController）
  ✅ Domain Layer（Game, Player, Cat等）
  ✅ Reactチームへの公開インターフェース（GameResult等）
  ✅ 全enum定義（Direction, CatState, CatMood, ToyType等）

  **依存方向（重要）**
  - Phaser → Application → Domain ✅
  - Domain → Phaser ❌（絶対にしない）
  - Domain → React ❌（絶対にしない）
  - Domain → React Interface（データ提供のみ）✅

  **重要な設計原則**
  - DomainはPhaserを知らない、Reactを知らない
  - Player.interact(targetId: string) - IDで参照
  - Cat.playWith(toyType: ToyType) - 型のみで参照
  - enum/型はDomain層で定義し、他層から参照
end legend

@enduml
