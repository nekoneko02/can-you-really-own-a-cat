# オブジェクトライフサイクル設計

このドキュメントは、クラス図・シーケンス図では表現しきれない、インスタンスの**生成・共有・永続化・破棄**の詳細を定義します。

---

## 原則

- **値オブジェクトは親のライフサイクルに準拠する**: 値オブジェクトは親エンティティと同じタイミングで生成・破棄されるため、原則として一覧に記載しない
- **エンティティと主要なサービスクラスのみ記載**: ライフサイクル管理が重要なクラスに絞る

---

## ライフサイクル一覧

| クラス | ドメイン | 実行環境 | 生成タイミング | スコープ | ユーザー間の共有可否 | 永続化 | 破棄タイミング | 備考 |
|--------|---------|---------|--------------|---------|-------------------|--------|--------------|------|
| **Cat** | Cat | クライアント/サーバー | ゲーム開始時 | セッションスコープ | 不可（プレイヤーごとに独立） | セッション（Cookie via iron-session） | ゲーム終了時 / セッション期限切れ | 猫の状態（なつき度等）はセッションに保存。DBには最終結果のみ保存（PlayLog用）。クライアント側でも状態管理、サーバー側でも更新処理 |
| **GameSession** | Game | サーバー | ゲーム開始時 | セッションスコープ | 不可（プレイヤーごとに独立） | セッション（Cookie via iron-session） | ゲーム終了時 / セッション期限切れ | セッションIDは保持しない（iron-sessionが管理）。**currentTurnはサーバー側で厳格に管理**（クライアントから渡さない、改ざん防止）。scenarioId、currentTurn、catを保持 |
| **Scenario** | Game/Scenario | サーバー | アプリケーション起動時 | アプリケーション全体 | **可（マスターデータ）** | DB（scenarios テーブル）またはJSON | アプリケーション終了時 | **全ユーザー共通のマスターデータ**。メモリキャッシュ推奨。不変。クライアントには送信しない（セキュリティ） |
| **Event** | Game/Scenario | サーバー | Scenario生成時 | Scenarioのライフサイクルに従う | 可（Scenarioに含まれる） | Scenarioと一緒に永続化 | Scenarioの破棄時 | Scenarioの集約内エンティティ。不変。必要なイベントのみクライアントに送信 |
| **Branch** | Game/Scenario | サーバー | Scenario生成時 | Scenarioのライフサイクルに従う | 可（Scenarioに含まれる） | Scenarioと一緒に永続化 | Scenarioの破棄時 | Scenarioの集約内エンティティ。不変。クライアントには送信しない（分岐ロジックの隠蔽） |
| **GameCanvas (React)** | Presentation | クライアント | ゲーム開始ボタンクリック時 | ページスコープ | 不可（プレイヤーごとに独立） | なし（UIコンポーネント） | ページ遷移時 / ブラウザバック時 | Reactコンポーネント。ゲーム全体のコンテナ |
| **シナリオUI (React)** | Presentation | クライアント | GameCanvasのマウント時 | GameCanvasのライフサイクルに従う | 不可（GameCanvasに含まれる） | なし（UIコンポーネント） | GameCanvasのアンマウント時 | Reactコンポーネント。GameServiceに依存する親コンポーネント |
| **EventUI (React)** | Presentation | クライアント | GameCanvasのマウント時 | GameCanvasのライフサイクルに従う | 不可（GameCanvasに含まれる） | なし（UIコンポーネント） | GameCanvasのアンマウント時 | Reactコンポーネント。イベント表示専用。propsのみ依存 |
| **ChoiceUI (React)** | Presentation | クライアント | GameCanvasのマウント時 | GameCanvasのライフサイクルに従う | 不可（GameCanvasに含まれる） | なし（UIコンポーネント） | GameCanvasのアンマウント時 | Reactコンポーネント。選択肢表示専用。propsのみ依存 |
| **ResultUI (React)** | Presentation | クライアント | GameCanvasのマウント時 | GameCanvasのライフサイクルに従う | 不可（GameCanvasに含まれる） | なし（UIコンポーネント） | GameCanvasのアンマウント時 | Reactコンポーネント。結果表示専用。propsのみ依存 |
| **GameAnimationComponent (React)** | Presentation | クライアント | GameCanvasのマウント時 | GameCanvasのライフサイクルに従う | 不可（GameCanvasに含まれる） | なし（UIコンポーネント） | GameCanvasのアンマウント時 | Reactコンポーネント。Phaser管理用 |
| **GameAnimation (Phaser)** | Presentation | クライアント | GameAnimationComponent.init() 呼び出し時 | ゲームセッションスコープ | 不可（プレイヤーごとに独立） | なし（ステートレス） | ゲーム終了時 / ページ遷移時 | Phaserシーン。ステートレス設計（状態はinit()で受け取る） |
| **GameApiClient** | Infrastructure | クライアント | シナリオUI生成時 | シナリオUIのライフサイクルに従う | 不可（シナリオUIに含まれる） | なし（ステートレス） | シナリオUIの破棄時 | HTTP通信のラッパー。1 ApplicationService = 1 ApiClient の原則。fetch()を抽象化、エラーハンドリング統一 |
| **GameService** | Application | サーバー | API Route呼び出し時 | リクエストスコープ | 不可（リクエストごとに生成） | なし（ステートレス） | リクエスト終了時 | Next.js API Route内で生成。ステートレス。UI層とDomain層の仲介役 |
| **SessionStore (iron-session)** | Infrastructure | サーバー | API Route呼び出し時 | リクエストスコープ | 不可（ライブラリが管理） | Cookie（暗号化） | セッション期限切れ | iron-sessionライブラリが提供。セッションIDの管理も含む。初回アクセス時に自動初期化 |
| **ScenarioRepository** | Infrastructure | サーバー | GameService生成時 | GameServiceのライフサイクルに従う | 不可（リクエストごとに生成） | なし（ステートレス） | GameServiceの破棄時 | マスターデータアクセス。キャッシュ機能を持つ |
| **ScenarioCache** | Infrastructure | サーバー | アプリケーション起動時 | アプリケーション全体 | 可（グローバルシングルトン） | なし（メモリキャッシュ） | アプリケーション終了時 | Scenarioマスターデータをメモリキャッシュ。サーバー再起動で再構築 |

---

## 重要な設計ポイント

### 1. Scenarioはマスターデータ（全ユーザー共通）

- ✅ **共有可**: すべてのプレイヤーが同じScenarioインスタンスを参照
- ✅ **不変**: 一度生成したら変更しない（イミュータブル）
- ✅ **キャッシュ**: ScenarioCacheでメモリキャッシュし、毎回DBから読み込まない
- ✅ **永続化**: DBまたはJSONファイルでマスターデータ管理

### 2. GameSessionはセッション情報のみ（値オブジェクト）

- ✅ **セッションID不要**: iron-sessionライブラリがセッションIDを管理
- ✅ **軽量**: currentTurn、scenarioId、catのみ保持
- ✅ **永続化**: Cookie（iron-sessionで暗号化）
- ✅ **プレイヤーごとに独立**: セッションが異なればGameSessionも異なる
- ✅ **currentTurnはサーバー側管理**: クライアントから渡さない、改ざん防止のため

### 3. Catはプレイヤー固有の可変状態

- ✅ **プレイヤーごとに独立**: セッションごとに異なるCatインスタンス
- ✅ **可変**: パラメータ変化で新しいインスタンスを返す（イミュータブルパターン）
- ✅ **永続化**: セッション（Cookie）+ 最終結果をDBに保存（PlayLog用）

### 4. GameAnimationはステートレス

- ✅ **状態を持たない**: init()でScenario、Cat、currentTurnを受け取る
- ✅ **描画のみ**: ドメインロジックは持たず、Scenarioに委譲
- ✅ **破棄と再生成**: ゲーム終了時に破棄、再開時に再生成

### 5. UI層の責務分離

- ✅ **EventUI**: イベントタイトルと詳細の表示のみ
- ✅ **ChoiceUI**: 選択肢の表示と選択の受付のみ
- ✅ **ResultUI**: 分岐後の結果テキスト表示のみ
- ✅ **GameAnimationComponent**: Phaserインスタンス管理のみ
- ✅ **疎結合**: 各UIコンポーネントは独立し、GameCanvasが統合

---

## データフロー

### ゲーム開始時

```text
1. ユーザーがシナリオIDを選択
2. iron-sessionで新しいセッションを作成（セッションID自動生成）
3. GameSessionを生成（scenarioId、currentTurn=1、catId）
4. Catを生成（デフォルト値）
5. セッションにGameSession + Catを保存（Cookie）
6. ScenarioCacheからScenarioを取得（キャッシュヒット）
7. GameAnimationをinit(scenario, cat, currentTurn=1)
```

### イベント進行時

```text
1. シナリオUIがGameApiClient.getCurrentEvent(scenarioId)を呼ぶ（ルール1: UI → ApiClient → Application → Domain）
2. GameServiceがSessionStoreからcurrentTurnを取得
3. GameServiceがScenario.getEventByTurn(currentTurn)を呼ぶ
4. シナリオUIがEventUIにpropsでイベント内容を渡す（ルール3: 親→子へprops渡し）
5. EventUIにイベント内容を表示
6. プレイヤーが選択肢をクリック（ChoiceUIが受付）
7. ChoiceUIが親（シナリオUI）にonChoiceSelected()でイベント通知（ルール3）
8. シナリオUIがGameApiClient.executeChoice(scenarioId, choiceId)を呼ぶ
9. GameServiceがSessionStoreからcurrentTurnとCatを取得
10. GameServiceがChoice.resultからEventResultを取得し、Catを更新
11. シナリオUIがGameApiClient.evaluateBranch(scenarioId, choiceId)を呼ぶ
12. GameServiceがSessionStoreからcurrentTurnとCatを取得
13. GameServiceがBranchを評価して次のイベントIDを決定
14. シナリオUIがResultUIにpropsで分岐後イベントを渡す（ルール3）
15. ResultUIが分岐後のイベントを表示
16. シナリオUIがGameApiClient.advanceToNextTurn()を呼ぶ
17. GameServiceがSessionStoreからGameSessionを取得、currentTurnをインクリメント
18. セッションに更新後のGameSession（currentTurn + Cat）を保存
```

### ゲーム終了時

```text
1. シナリオUIがGameApiClient.isScenarioComplete(scenarioId)を呼ぶ（ルール1）
2. GameServiceがSessionStoreからcurrentTurnを取得
3. GameServiceがScenario.isComplete(currentTurn)を呼ぶ
4. trueが返された場合、GameCanvasに終了通知
5. 最終結果をPlayLogとしてDBに保存
6. セッションをクリア（Cookie削除）
7. GameAnimationを破棄
```

---

## スケーラビリティ考慮

### 複数サーバー構成

- ✅ **セッション**: Cookie（iron-session）でクライアント側に保存
- ✅ **Scenarioキャッシュ**: 各サーバーでメモリキャッシュ（DBから読み込み）
- ✅ **ステートレス**: サーバー間で状態共有不要

### スケールアウト

- ✅ **水平スケール可能**: セッション情報がCookieなので、サーバーを増やしても問題なし
- ✅ **ロードバランサー**: セッションスティッキー不要

---

## セキュリティ考慮

### セッション管理

- ✅ **iron-session**: Cookieを暗号化して保存
- ✅ **CSRF対策**: Next.jsのAPI Routeでトークン検証
- ✅ **セッション期限**: 適切な有効期限を設定（例: 24時間）

### マスターデータ改ざん防止

- ✅ **サーバーサイドでScenarioを管理**: クライアントからScenarioを送信しない
- ✅ **イベント結果の検証**: クライアントから送られたchoiceIdを検証

---

## テスト戦略

### 単体テスト

- ✅ **ドメインモデル**: すべて単体テスト（Jest）
- ✅ **不変性**: 値オブジェクトの不変性を検証

### 統合テスト

- ✅ **GameService**: Scenarioリポジトリとの統合テスト
- ✅ **セッション**: iron-sessionとの統合テスト

### E2Eテスト

- ✅ **シナリオ実行**: Playwrightでゲーム開始〜終了までの流れをテスト
- ✅ **分岐**: 異なる選択肢での分岐動作を検証

---

以上です。このドキュメントを基に、実装時の判断を行います。
