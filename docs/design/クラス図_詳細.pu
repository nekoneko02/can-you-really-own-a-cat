@startuml クラス図（詳細版）

title ドメイン層クラス図（実装構造）

' ====================================================================
' このクラス図は実際のディレクトリ構造を反映しています
' ドメインモデル図（ドメインモデル.pu）の概念設計に対応する実装詳細です
' ====================================================================

' ====================================================================
' 【ルール1】レイヤ依存方向（DDD原則）
' ====================================================================
' 依存方向: UI → Application → Domain ← Infrastructure
'
' - 依存は上記方向のみ許可（逆方向禁止）
' - Domain と Infrastructure の関係は「抽象（Domain）← 実装（Infrastructure）」
'
' レイヤ別依存可能対象:
'   UI層:
'     - 依存OK: Application層
'     - 依存NG: Domain層, Infrastructure層
'   Application層:
'     - 依存OK: Domain層（集約ルート, ドメインサービス, Repositoryインターフェース）
'     - 依存NG: Infrastructure層の実装
'   Domain層:
'     - 依存OK: 同一集約内モデル, 抽象インターフェース
'     - 依存NG: 他集約内部, UI層, Application層, Infrastructure層
'   Infrastructure層:
'     - 依存OK: Domain層の抽象（Repositoryインターフェースなど）
'     - 依存NG: Domainロジック, Application層, UI層
' ====================================================================

' ====================================================================
' 【ルール2】集約横断参照（別ドメイン参照）
' ====================================================================
' 別集約の内部エンティティ/ValueObjectへの直接参照は禁止
'
' 対応方法（いずれか）:
'   A. IDによる参照（オブジェクト直接参照禁止）
'   B. ドメインサービスによる調停
'   C. Domain側に最小限の抽象インターフェースを作成し依存逆転
'
' 例（方法C: 依存逆転）:
'   Game ドメインの Branch が Cat ドメインの Cat を参照する場合
'   1. Game ドメインに ICat インターフェースを作成（必要最小限の属性・メソッドのみ）
'   2. Branch は ICat に依存
'   3. Cat が ICat を実装
' ====================================================================

' ====================================================================
' 【ルール3】UIコンポーネント設計原則
' ====================================================================
' 親だけがApplicationServiceに依存し、子へ値・イベントを渡す
'
' 推奨理由:
'   - 責務分離: 親がユースケース担当、子は描画とイベント通知に専念
'   - 再利用性: 子コンポーネントはpropsのみに依存し、再利用しやすい
'   - テスト容易性: 子はpropsをモックするだけでテスト可能
'
' 例:
'   GameCanvas (親) → GameService に依存
'     ↓ props渡し
'   EventUI (子) → GameService に依存しない、propsのみ受け取る
' ====================================================================

' ====================================================================
' 【ルール4】クラス図表記ルール
' ====================================================================
' - Publicな属性・メソッドのみ記載（Privateは記載しない）
' - 値オブジェクトは親のライフサイクルに準拠するため、必要最小限のみ記載
' ====================================================================

' ====================================================================
' Catサブドメイン (src/domain/cat/)
' ドメインモデル図: package "ねこ (Cat)"
' ====================================================================
package "Cat Domain" as CatDomain <<Rectangle>> {
  note as CatNote
    **ディレクトリ**: src/domain/cat/
    **ドメインモデル対応**: 「ねこ (Cat)」パッケージ
    **公開API**: @/domain/cat (index.ts経由)
  end note

  class Cat <<Entity>> {
    + id: string
    + name: string
    + affectionLevel: AffectionLevel
    + stressLevel: StressLevel
    + health: Health
    + hunger: Hunger
    --
    + {static} createDefault(id, name): Cat
    + updateAffection(newAffection): Cat
    + updateStress(newStress): Cat
    + updateHealth(newHealth): Cat
    + updateHunger(newHunger): Cat
    + feed(): Cat
    + play(): Cat
    + applyChange(change: ParameterChange): Cat
  }

  class AffectionLevel <<ValueObject>> {
    + value: number
    --
    + increase(amount): AffectionLevel
    + decrease(amount): AffectionLevel
    + equals(other): boolean
  }

  class StressLevel <<ValueObject>> {
    + value: number
    --
    + increase(amount): StressLevel
    + decrease(amount): StressLevel
    + equals(other): boolean
  }

  class Health <<ValueObject>> {
    + value: number
    --
    + increase(amount): Health
    + decrease(amount): Health
    + equals(other): boolean
  }

  class Hunger <<ValueObject>> {
    + value: number
    --
    + increase(amount): Hunger
    + decrease(amount): Hunger
    + equals(other): boolean
  }

  Cat "1" --> "1" AffectionLevel
  Cat "1" --> "1" StressLevel
  Cat "1" --> "1" Health
  Cat "1" --> "1" Hunger
}

' ====================================================================
' Gameサブドメイン (src/domain/game/)
' ドメインモデル図: package "ゲーム (Game)"
' ====================================================================
package "Game Domain" as GameDomain <<Rectangle>> {
  note as GameNote
    **ディレクトリ**: src/domain/game/
    **ドメインモデル対応**: 「ゲーム (Game)」パッケージ
    **公開API**: @/domain/game (index.ts経由)
  end note

  ' ====================================================================
  ' 別ドメイン参照用インターフェース
  ' ====================================================================

  interface ICat <<Interface>> {
    + id: string
    + affectionLevel: AffectionLevel
    + stressLevel: StressLevel
    + health: Health
    + hunger: Hunger
    --
    + applyChange(change: ParameterChange): ICat
  }

  note right of ICat
    **用途**: Branch が Cat を参照するためのインターフェース
    必要最小限の属性とメソッドのみを定義
  end note

  ' ====================================================================
  ' ゲーム進行管理 (src/domain/game/ 直下)
  ' ドメインモデル図: 3-1. ゲーム進行管理
  ' ====================================================================

  class GameSession <<ValueObject>> {
    + playerId: string
    + scenarioId: ScenarioId
    + currentTurn: number
    + catId: string
    --
    + advanceTurn(): GameSession
  }

  class ScenarioId <<ValueObject>> {
    + value: string
    --
    + equals(other): boolean
  }

  GameSession "1" --> "1" ScenarioId

  ' ====================================================================
  ' Scenarioサブドメイン (src/domain/game/scenario/)
  ' ドメインモデル図: 3-2. シナリオ (Scenario)
  ' ====================================================================
  package "Scenario Subdomain" as ScenarioPackage <<Rectangle>> {
    note as ScenarioNote
      **ディレクトリ**: src/domain/game/scenario/
      **ドメインモデル対応**: 「シナリオ (Scenario)」パッケージ
      **公開API**: @/domain/game (経由でexport)
    end note

    class Scenario <<Entity>> {
      + id: string
      + name: ScenarioName
      + purpose: ScenarioPurpose
      + duration: number
      + events: Event[]
      + branches: Branch[]
      --
      + getEventByTurn(turn: number): Event
      + getEventById(eventId: string): Event | undefined
      + getBranchByTurn(turn: number): Branch | undefined
      + isComplete(turn: number): boolean
    }

    class Event <<Entity>> {
      + id: string
      + title: EventTitle
      + description: EventDescription
      + choices: Choice[]
      --
      + getChoiceById(choiceId: string): Choice | undefined
      + getTitle(): EventTitle
      + getDescription(): EventDescription
      + getChoices(): Choice[]
    }

    class Branch <<Entity>> {
      + id: string
      + turnNumber: number
      + cases: BranchCase[]
      + defaultEventId: string
      --
      + evaluate(cat: ICat, choiceId: string): string
    }

    class BranchCase <<ValueObject>> {
      + condition: BranchCondition
      + nextEventId: string
    }

    class BranchCondition <<ValueObject>> {
      + type: string
      + targetParameter: string
      + operator: string
      + threshold: number
      --
      + evaluate(cat: ICat, choiceId: string): boolean
    }

    class ScenarioName <<ValueObject>> {
      + value: string
      --
      + equals(other): boolean
    }

    class ScenarioPurpose <<ValueObject>> {
      + value: string
      --
      + equals(other): boolean
    }

    class EventTitle <<ValueObject>> {
      + value: string
      --
      + equals(other): boolean
    }

    class EventDescription <<ValueObject>> {
      + value: string
      --
      + equals(other): boolean
    }

    class Choice <<ValueObject>> {
      + id: string
      + text: string
      + result: EventResult
      --
      + equals(other): boolean
      + getResult(): EventResult
    }

    class EventResult <<ValueObject>> {
      + changes: ParameterChange[]
      --
      + getChanges(): ParameterChange[]
    }

    class ParameterChange <<ValueObject>> {
      + parameterType: ParameterType
      + changeAmount: number
    }

    enum ParameterType <<ValueObject>> {
      affection
      stress
      health
      hunger
      playerStress
      playerFatigue
      playerEnergy
      roomCleanliness
      totalCost
    }

    ' Scenario集約内の関連
    Scenario "1" --> "1" ScenarioName
    Scenario "1" --> "1" ScenarioPurpose
    Scenario "1" *-- "0..*" Event: 集約
    Scenario "1" *-- "0..*" Branch: 集約

    Event "1" --> "1" EventTitle
    Event "1" --> "1" EventDescription
    Event "1" --> "1..*" Choice

    Choice "1" --> "1" EventResult: 保持

    Branch "1" --> "1..*" BranchCase
    Branch ..> ICat: 参照
    BranchCase "1" --> "1" BranchCondition
    BranchCondition ..> ICat: 参照

    EventResult "1" --> "0..*" ParameterChange
    ParameterChange "1" --> "1" ParameterType
  }

  ' ゲーム進行管理とシナリオの関連
  GameSession ..> Scenario: scenarioId参照
}

' ====================================================================
' Application層 (src/application/)
' ドメインモデル図: GameFlowService に相当
' ====================================================================
package "Application Layer" as AppLayer <<Rectangle>> {
  note as AppNote
    **ディレクトリ**: src/application/
    **ドメインモデル対応**: GameFlowService（ドメインサービス）
  end note

  class GameService <<ApplicationService>> {
    + loadScenario(scenarioId: ScenarioId): Scenario
    + createSession(scenarioId: ScenarioId, catId: string): GameSession
    + getCurrentEvent(scenarioId: ScenarioId, turn: number): Event
    + getChoiceById(scenarioId: ScenarioId, turn: number, choiceId: string): Choice
    + executeChoice(scenarioId: ScenarioId, turn: number, choiceId: string, cat: Cat): Cat
    + evaluateBranch(scenarioId: ScenarioId, turn: number, choiceId: string, cat: Cat): Event
    + advanceToNextTurn(session: GameSession): GameSession
    + isScenarioComplete(scenarioId: ScenarioId, turn: number): boolean
  }

  note right of GameService
    **役割**: UIコンポーネントからのドメインアクセスを仲介
    - UI層はこのサービス経由でのみドメインにアクセス（ルール1準拠）
    - Scenarioの取得、イベント取得、選択肢実行、分岐評価を提供
  end note
}

' ====================================================================
' Presentation層 (src/presentation/)
' ====================================================================
package "Presentation Layer" as PresentationLayer <<Rectangle>> {
  note as PresentationNote
    **ディレクトリ**: src/presentation/
    **役割**: UI/UX層（React Component、Phaser Scene）
  end note

  class GameCanvas <<ReactComponent>> {
    + render(): JSX.Element
    + onGameEnd(): void
  }

  note right of GameCanvas
    **役割**:
    - 上半分: GameAnimationComponent
    - 下半分: シナリオUI
    2つの独立コンポーネントを保持
  end note

  class シナリオUI <<ReactComponent>> {
    + render(): JSX.Element
    + onChoiceSelected(choiceId: string): void
    + onNextClicked(): void
  }

  note right of シナリオUI
    **役割**: シナリオロジック実行の主体（ルール3準拠）
    - GameServiceに依存し、ユースケースを実行
    - 子コンポーネント（EventUI, ChoiceUI, ResultUI）へpropsで値を渡す
    - 子からのイベント通知を受け取り、GameServiceを呼び出す
  end note

  class EventUI <<ReactComponent>> {
    + displayEvent(event: EventData): void
  }

  note right of EventUI
    **役割**: イベントタイトルと詳細を表示（propsのみ依存）
    - GameServiceに依存しない
    - 親（シナリオUI）からpropsでEventDataを受け取る
  end note

  class ChoiceUI <<ReactComponent>> {
    + displayChoices(choices: ChoiceData[]): void
    + onChoiceSelected(choiceId: string): void
  }

  note right of ChoiceUI
    **役割**: 選択肢を表示し、選択を受け付ける（propsのみ依存）
    - GameServiceに依存しない
    - 親（シナリオUI）からpropsでChoiceDataを受け取る
    - 選択時は親にイベント通知
  end note

  class ResultUI <<ReactComponent>> {
    + displayResult(result: ResultData): void
    + onNextClicked(): void
  }

  note right of ResultUI
    **役割**: 分岐後の結果テキストを表示（propsのみ依存）
    - GameServiceに依存しない
    - 親（シナリオUI）からpropsでResultDataを受け取る
    - 次へボタンクリック時は親にイベント通知
  end note

  class GameAnimationComponent <<ReactComponent>> {
    + init(): void
    + setBackground(backgroundId: string): void
    + setCatEmotion(emotion: string): void
  }

  note right of GameAnimationComponent
    **役割**: Phaserインスタンス管理
    GameAnimation への描画指示
  end note

  class GameAnimation <<PhaserScene>> {
    + init(): void
    + create(): void
    + preload(): void
    + renderBackground(backgroundId): void
    + renderCat(emotion): void
  }

  note right of GameAnimation
    **役割**: 描画専用
    - Scenarioは呼び出さない
    - 背景・猫のイラスト描画のみ
  end note

  ' ====================================================================
  ' API Client層 (src/infrastructure/api/)
  ' ====================================================================

  class GameApiClient <<ApiClient>> {
    + loadScenario(scenarioId: ScenarioId): Promise<Scenario>
    + getCurrentEvent(scenarioId: ScenarioId): Promise<Event>
    + executeChoice(scenarioId: ScenarioId, choiceId: string): Promise<Cat>
    + evaluateBranch(scenarioId: ScenarioId, choiceId: string): Promise<Event>
    + advanceToNextTurn(): Promise<GameSession>
    + isScenarioComplete(scenarioId: ScenarioId): Promise<boolean>
  }

  note right of GameApiClient
    **役割**: GameServiceへのAPI呼び出しを担当
    - UI層とサーバー側Application層の通信を仲介
    - 1 ApplicationService = 1 ApiClient の原則
    - fetch()のラッパー、エラーハンドリング統一
    - 型安全なAPI呼び出しを提供

    **重要**: currentTurnはサーバー側で管理
    - クライアントからcurrentTurnを渡さない
    - サーバーがセッションからcurrentTurnを取得
  end note

  GameCanvas "1" --> "1" シナリオUI
  GameCanvas "1" --> "1" GameAnimationComponent

  シナリオUI "1" --> "1" EventUI
  シナリオUI "1" --> "1" ChoiceUI
  シナリオUI "1" --> "1" ResultUI

  GameAnimationComponent "1" --> "1" GameAnimation
}

' ====================================================================
' 層間の依存関係
' ====================================================================
' Application → Domain（OK）
GameService ..> Scenario
GameService ..> GameSession
GameService ..> Event
GameService ..> Cat

' UI → ApiClient → Application（OK: ルール1, ルール3準拠）
' 親コンポーネント（シナリオUI）のみがGameApiClientに依存
' GameApiClientがHTTP経由でGameServiceを呼び出す
シナリオUI ..> GameApiClient
GameApiClient ..> GameService: HTTP/API Route経由

' UI → UI（OK）
' 親から子へのprops渡し（依存ではなく構成）
GameCanvas ..> シナリオUI
GameCanvas ..> GameAnimationComponent
シナリオUI ..> EventUI: props渡し
シナリオUI ..> ChoiceUI: props渡し
シナリオUI ..> ResultUI: props渡し
GameAnimationComponent ..> GameAnimation

' ====================================================================
' ドメイン間のインターフェース実装
' ====================================================================
Cat ..|> ICat: 実装

' ====================================================================
' サブドメイン間の関係（概念的）
' ドメインモデル図の関連に対応
' ====================================================================
GameSession ..> Cat: catId参照\n（ドメインモデル対応）

' ====================================================================
' 凡例
' ====================================================================
legend right
  **凡例**
  <<Entity>>: エンティティ（一意性を持つ）
  <<ValueObject>>: 値オブジェクト（不変）
  <<ApplicationService>>: アプリケーションサービス
  <<PhaserScene>>: Phaserゲームシーン
  <<ReactComponent>>: Reactコンポーネント
  <<Interface>>: インターフェース（ドメイン間参照用）

  **ドメインモデルとの対応**
  このクラス図の構造は、ドメインモデル図
  （ドメインモデル.pu）の概念設計を
  実際のコードとして実装したものです。

  **index.tsによる公開API**
  各サブドメインはindex.tsで公開APIを定義し、
  サブドメイン間の依存を制御しています。

  **DDD原則の適用（ルール1-4）**
  - ルール1: レイヤ依存 UI → Application → Domain ← Infrastructure
  - ルール2: 別集約参照は、IDまたはインターフェース経由（ICat参照）
  - ルール3: 親コンポーネントのみがApplicationServiceに依存
    （シナリオUI → GameService、子はpropsのみ依存）
  - ルール4: Public属性・メソッドのみ記載、値オブジェクトは最小限
end legend

@enduml
